# Test short-circuit relational operators with function calls.
function okay_to_call() : bool { assert true; return true; }
function not_okay_to_call() : bool { assert false; return true; }
{
  true || not_okay_to_call();
  false || okay_to_call();
  true && okay_to_call();
  false && not_okay_to_call();
}

function to_s(n:int):string {
  if (n == 0) {
    return "zero";
  } else if (n == 1) {
    return "one";
  } else {
    return "many";
  }
}
s : string = "";
for (i : int = 0; i < 5; ++i) {
  s += to_s(i) + " ";
}
puts(s);

function triangular_number(n : int) : int {
  j : int = 0;
  for (i : int = 1; i <= n; ++i) {
    j += i;
  }
  return j;
}
for (i:int = 0; i < 20; ++i) {
  print(i, "\t", triangular_number(i), "\n");
}

function name_from_list(n : int) : string {
  names:list<string> = [ "one", "two", "three" ];
  name:string = names[n - 1];
  return name;
}

# FIXME: what should we do about map literals?
names:map<int,string> = new map<int,string>();
names[1] = "one"; names[2] = "two"; names[3] = "three";
function name_from_map(n:int):string {
  return names[n];
}

# Check the two functions are equivalent.
{
  for (i:int = 1; i < names.size(); ++i) {
    assert name_from_list(i) == name_from_map(i);
  }
}

# Test map methods.
{
  assert names.has_key(1);
  assert !names.has_key(12);
  assert names.has_value("one");
  assert !names.has_value("many");
  assert names.to_s() == "{1=one, 2=two, 3=three}";
  keys: list<int> = names.keys();
  assert keys.to_s() == "[1, 2, 3]";
  values: list<string> = names.values();
  assert values.to_s() == "[one, two, three]";
  assert names.size() == 3;
  assert names.remove(2).to_s() == "{1=one, 3=three}";
  assert names.size() == 2;
  assert names.clear().to_s() == "{}";
  assert names.size() == 0;
}
