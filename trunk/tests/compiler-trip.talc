#!/usr/bin/talc

# Test assertions.
assert true;
assert 0 == 0;

# Test Unicode escapes in string literals.
assert "\u0068\u0065\u006c\u006c\u006f\u0020world" == 'hello world';

i := 0;

if (true) {
 ++i;
} else {
 assert false;
}

if (false) {
 assert false;
} else {
 ++i;
}

if (true) {
 ++i;
}

if (false) {
 assert false;
}

puts([true, false]);
puts(true, false);
puts(true);
puts(false);
["hello", "world"];
puts(1, 2, 3, 4);
puts([1, 2, 3, 4]);

if (true) {
 ++i;
} else {
 assert false;
}

if (!true) {
 assert false;
} else if (!false) {
 ++i;
} else {
 assert false;
}

if (false && true) {
 assert false;
}
if (true && false) {
 assert false;
}
if (true && true) {
 ++i;
}
if (false && false) {
 assert false;
}

if (false || true) {
 ++i;
}
if (true || false) {
 ++i;
}
if (true && true) {
 ++i;
}
if (false && false) {
 assert false;
}

if (true == false) {
 assert false;
}
if (false == true) {
 assert false;
}
if (true == true) {
 ++i;
}
if (false == false) {
 ++i;
}

if (true != false) {
 ++i;
}
if (false != true) {
 ++i;
}
if (true != true) {
 assert false;
}
if (false != false) {
 assert false;
}

# Test unary and binary operators.
assert 1! == 1;
assert 2! == 2;
assert 3! == 6;
assert 4! == 24;
assert 5! == 120;
assert 6! == 720;
assert 7! == 5040;
assert 2 == 1 << 1;
assert 1 << 10 == 1024;
assert 1024 >> 2 == 256;
assert -1 * 1024 == -1024;
assert 1024 % 2 == 0;
assert 1025 % 2 == 1;
assert (7 & 2) == 2;
assert (2 | 3) == 3;
assert (2 ^ 3) == 1;
assert (2 ** 3) == 8;
assert (-3 ** 2) == -9;
assert -1024 - -1024 == 0;
assert 3*4 == 12;
assert 3.0*4.0 == 12.0;
assert "hello" != null;
assert 1 + 1 == 2;
assert 1.0 + 1.0 == 2.0;
assert "hello" + " " + "world" == "hello world";
assert 1 < 2;
assert 2 > 1;
assert !(1 > 1);
assert !(1 < 1);
assert 1 <= 1;
assert 1 <= 2;

if (true) {
 ++i;
} else if (true) {
 assert false;
} else if (true) {
 assert false;
} else if (true) {
 assert false;
} else if (true) {
 assert false;
} else {
 assert false;
}

assert i == 14;

{
 three := (1 + 2);
 assert three == 3;
}

# Test compile-time string concatenation.
{
 s := ("hello" + " " + "world");
 assert s == "hello world";
}

# Test order of evaluation.
{
 s:string = "one";
 if (s.starts_with(s = "two")) {
  assert false;
 }
}

# Test "do" loops.
{
 i := 0;
 do {
  ++i;
 } while (i < 5);
 assert i == 5;
}

# Test "for" loops.
{
 # Tests that we cope when any part of a "for" statement is missing.
 
 # No initializer.
 {
  i := 0;
  j := 0;
  for (; i < 5; ++i) {
   ++j;
  }
  assert i == 5;
  assert j == 5;
 }
 
 # No increment.
 {
  j := 0;
  for (i := 0; i < 5;) {
   ++i;
   ++j;
  }
  assert j == 5;
 }
 
 # No condition.
 {
  j := 0;
  for (i := 0; ; ++i) {
   if (i >= 5) {
    break;
   }
   ++j;
  }
  assert j == 5;
 }
 
 # Tests the for-each functionality.
 words:list<string> = ["this", "is", "a", "test"];
 
 # For-each with index.
 {
  j := 0;
  for (i, word in words) {
   assert words[i] == word;
   ++j;
  }
  assert j == words.size();
 }
 
 # For-each without index.
 {
  j := 0;
  for (word in words) {
   assert words[j] == word;
   ++j;
  }
  assert j == words.size();
 }
}

# Test "while" loops.
{
 i := 0;
 while (i < 5) {
  ++i;
 }
 assert i == 5;
}
