* [easy] documentation!
 + make sure all errors we can emit are documented.
 + mini comparisons against Java, Perl, Python, and Ruby.
 + add some way to doc-comment class, function, and variable definitions. documentation should be available at run-time, and should be available for automatic dumping (like --dump-classes or a  better version of Ruby's ri).

* [easy] better tests/demos.

* [medium] optimize integer literals:
 + never call "new IntegerValue"; always use IntegerValue.valueOf (in generated code and hand-written code alike), and implement caching like in java.lang.Integer.
 + for some number of the most important values (-1, 0, and 1?), have them available as fields in IntegerValue, and have the code generator use getstatic instead of calling IntegerValue.valueOf.

* [medium] replace "prelude.txt" with some kind of textual "include" system. (note: the prelude is currently broken and disabled.)
 + add the remaining prelude math functions in "math.talc" as a trivial example.
 + add "set.talc" as an example, implementing the equivalent of Java's HashSet. (would require user-defined parametric types!)
 + should have some kind of "include path" (accessible in scripts as a list<string>?) that by default includes something like /usr/share/talc/<major-version?>/ so third-parties can add their libraries to the system independently of talc.

* [medium] improve Lexer.getLocation so we provide the start and end line/column rather than just the end (even just the start would be better than just the end, as we have at the moment; error messages point to the end of the problem where the start would be more natural).

* [easy] "assert" statements.
 + fix the "tests" to actually use these, so we get assertion failures if anything goes wrong.

* [medium] should add an "Iterable" interface, change for-each to expect its expression has that type and then invoke "Iterable.iterator()" and use it. (though how does that get us keys as well as values? maybe not "Iterable" so much as "ForEachAble<K,V>"? "has_next() : bool", "key() : K", and "value() : V"?)

* [medium] warnings about hiding? what kinds are okay and what kinds aren't?

* [easy] FunctionDefinition and VariableDefinition should have a common ancestor so we can treat them more uniformly. This will probably simplify some of the code.

* [medium] improve globals handling.
 + have the pre-execution constant-folding/constant-propagation ensure that all global constants have been fully inlined?
 + automate the generation of the globals section in the man page.

* [medium] can we use List<VariableDefinition> (with null initializers?) in AstNode.FunctionDefinition for the parameter list?

* [medium] add map literals.

* [medium] simplifier should know about types other than integers:
           simplifier should know about "bool" and use this to simplify "if" statements and loops.
           simplifier should know about "string" and concatenate literals at compile-time.

* [medium] implement the ? : ternary operator.

* [medium] implement regexp (type, literals (?), and basic operations). (a literal would give us compile-time regexp checking and ahead-of-time/once-off Pattern compilation.) go back over core library and see where we could usefully use regexp instead of string. (overloading might be handy.)

* [medium] finish user-defined classes.
 + "final" (and make all built-in classes final?)
 + "extends"
 + check for inheritance cycles.
 + "implements"
 + class methods
 + class fields (?)
 + final methods (?)

* [medium] overloaded methods/functions. useful for "system". probably some restriction like "no ambiguous/confusing overloads (ones where compile-time selection of an overload could produce different results than you'd expect if you thought overloads were selected at run-time)". http://www.informit.com/articles/article.aspx?p=31551&seqNum=4&rl=1

* [hard] function types, so we can add something like list<T>.map(function(e:T):T):list<T>.
 + parallel map.

* [hard] operator overloading?

* [hard] check that you can't drop off the bottom of a non-void function (i.e. must "return").

* [hard] exceptions, try-catch-finally, throw.

* [future] consider "to_b" to make the "match" idiom even more comfortable. too liable to be abused?

* [future] Pike talks about reducing "stutter" in Sawzall, which is certainly a problem in Java (especially since generics), though not yet in Talc thanks to type inference and richer literals:
  Conversion operators translate values from one type to another, and encapsulate a wide range of conversions. For instance, to extract the ﬂoating point number represented by a string, one simply converts the value:
    f: float;
    s: string = "1.234";
    f = float(s);
  Some conversions take parameters; for example
    string(1234, 16)
  generates the hexadecimal representation of the integer, while
    string(utf8_bytes, "UTF-8")
  will interpret the byte array in UTF-8 representation and return a string of the resulting Unicode character values.
  For convenience, and to avoid the stutter endemic in some languages’ declaration syntaxes, in initializations the appropriate conversion operation (with default parameter values) is supplied implicitly by the compiler. Thus
    b: bytes = "Hello, world!\n";
  is equivalent to the more verbose
    b: bytes = bytes("Hello, world!\n", "UTF-8");

* [future] some kind of equivalent of ObjC's "describe"/Ruby's "inspect"? maybe machine-generated?

* [future] is a "switch" statement sufficiently useful to be worth adding? what kind?

* [future] do we need a "char" primitive type? scripting languages' higher-level string operations make most char-grubbing unnecessary. single-character strings might be sufficient. explicit char support might be clearer/more natural for the target audience. (but if we give them char, will they waste time doing C-like string manipulation instead of learning the higher-level stuff?) or int.to_char():string and string.asc():int (like Perl chr/ord)? we currently have the former but not the latter, and it actually works okay, though the name is a bit awkward.

* [future] if we're going to have varargs "print" and "puts" built-ins, should we offer the same to user-defined functions? note that print and puts are special not only in that they can have any number of arguments, but also in that each argument can have a different type (though we could say they take object... [or whatever our notation is] because we call to_s on each argument; this would be cleaner and simpler). note that C-style varargs have problems compared to passing around a list, so really i'm talking about Java-like syntactic sugar (removing the need for [ and ] around the expression list), though at a loss of expressiveness and increase in complication. i think this is a questionable idea, but so is having magic "print" and "puts", but their functionality is invaluable in easing people into the water.

* [future] should the "for" initialization be as general as in similar languages? how can we do that without the hateful comma operator?

LIBRARY

http://www.ferite.org/ - quite nice; good documentation. future plans smelled of overcomplexificationing. wonder what it died of? and how Talc can avoid the same fate?

http://blogs.sun.com/chrisoliver/resource/f3.html - "format as" looks interesting. otherwise quite nasty.

C#'s System.IO.File is pretty nice, though i'm unconvinced by the the File/Directory split. note that their File only has static methods that take String pathnames. there's a separate FileInfo class (like "struct stat").

# environment variables
should "getenv" be generalized to ENV:map<string, string>? probably needs to be a special type with JNI-backed get and put that actually modify the environment. will that upset the JVM?
how should we offer access to Java's system properties? there's quite a parallel with environment variables, so we should probably follow a similar route.
we should offer Talc version information to interested scripts. how? system property? global variables? something like TALC_VERSION: string = "1.7.3" would be simplest, but there are lots of alternatives, and we should probably wait until we have a concrete need to distinguish versions (though that will, of course, be too late for someone).

should exit call System.exit or raise a SystemExitException as in most scripting languages?
die(...):void - puts(...);exit(1); # should output to stderr. include source location? warn() too?
sleep(ms:int):void # what time unit? integer ms? real s?

# subprocesses
should "shell" and "system" use a "status" type instead of "int" for the exit code making it easier to check for signals and the like?
should "shell" and "system" actually just be two overloaded "system" methods?
what should "backquote" do with the exit code?
should we offer an ability to separate stdout and stderr? to run in a specific directory?

object.compareTo # or comparable interface?
object.equals # have == call "equals", but have the default "equals" be identity? auto-generate field-by-field "equals"?
object.hashCode # or hashable interface (also requiring "equals")?

int.to_s(base:int) # currently, we don't have overloading, so this is called int.to_base(base:int).

TalcPrimitives: chmod, chown, lstat, stat

shouldn't "file" really be "path"?
file.chmod(mode:int):bool # plus symbolic constants?
file.chown(uid:int, gid:int):bool
file.is_reg():bool # et cetera? or should all this stuff be via stat?
file.glob(pattern:string):list<string> # should support zsh-like ** patterns.
file.lstat():stat
file.stat():stat
file.readdir():list<stat> # file.children():list<string> or somesuch?
file.delete():bool

url.read():string # read entire url as one string so people don't have to mess with curl(1)/wget(1).

string.substring(offset:int, length:int):string # or startIndex/endIndex? is this actually useful?
string.chomp():string # remove trailing newline; do we need this, given trim? Python doesn't seem to. mad mentions having had to fix a bug in a script relating to chomp ignoring '\r'.

# random class backed by java.util.Random
random.reset(seed:int):void
random.nextInt(n:int):int
random.nextReal():real
RANDOM:random # convenience instance
int.random(n:int):int # convenience using global RANDOM
real.random():real # convenience using global RANDOM

# should we have a "math" class of static methods, or a "math" library of global functions?
# the latter is less Java-like, but probably more popular and convenient for the intended users.
math.sin => Math.sin
math.cos => Math.cos
math.tan => Math.tan
math.asin => Math.asin
math.acos => Math.acos
math.atan => Math.atan # and atan2?
math.sinh => Math.sinh
math.cosh => Math.cosh
math.tanh => Math.tanh
math.exp => Math.exp

Perl-like pack/unpack?
Perl/Python/Ruby-like tr/tr_d? sufficiently useful?
should ARGV0 be of type "File" rather than "string"?
access to stderr? ability to print/puts to files/sockets/pipes?

how should "printf"-like functionality be implemented? string.format? (int|real|string).format methods?

# the need for these is demonstrated by "binomial-triangle.talc"...
list<T>.n_copies(n:int,item:T):list<T> # returns a new list with 'n' copies of 'item'.
list<T>.copy():list<T> # clone/copy the list. need such a method on all mutable containers.
string.n_copies(n:int,s:string):string # returns a new string of 'n' concatenated copies of 's', or, better...
string.dup(n:int):string # returns a new string of 'n' concatenated copies of 'this'
some kind of "format using" functionality.

time_s() : int # like Unix time(0).
time_ms() : int # like System.currentTimeMillis.
time_ns() : int # like System.currentTimeNanos.
some kind of class like our StopWatch.

something like Basic's ability to turn function-call tracing on? generate suitable byte-code to output something on every method entry/exit, nicely lined-up and with arguments and return values?

should list<t>.peek_back and list<T>.peek_front just be "back" and "front"?
should list<t>.pop_back and list<T>.push_back just be "pop" and "push"?
should we have list<T>.find(e:T):int ? should it take a start_index:int too, or return list<int>?
should FILE_SEPARATOR and PATH_SEPARATOR be in class "file"?

make sure all "value" classes return sensible hashCodes!

* language defect:
      a[i] = 0;        # OK
      x = a[i];        # OK
      a[i] = a[i] + 1; # OK
      a[i] += 1;       # ERROR
      a[i]++;          # ERROR
      ++a[i];          # ERROR
  it's a mistake to translate [] and []= in the parser. i think we do need some kind of AstNode.IndexExpression, and to do the __get_item__/__set_item__ translation in a context-sensitive way. not clear on the details, but this will have to be looked at eventually. i don't mind outlawing ++ and -- on these expressions, but compound assignment seems like something that should work.

* report better errors than 'no instance method "__get_item__" in class int' for talc -e '1[23];'.
  how public should those special names be?
  are we up-front about this, and using it as a mechanism for user-defined classes to support [] and []=?
  i don't think that's such a bad idea, compared to "operator []" and the like.
  but we should still talk to the user in terms of what they wrote.

* report sensible error (instead of stack overflow in the type inference code) for:
s : = "x";
if (x.starts_with("/")) {
  s := "x" + s;
}

* report sensible error when global function used before definition. (or cope, as we do with methods? global variables obviously shouldn't be treated like fields in terms of usability before definition, and global functions can refer to global variables, so presumably we should treat global functions specially to avoid this kind of weirdness?)

* in the JVM code generator, we should try to reuse local variable slots when variables go out of scope. at the moment, we have really large numbers of locals which (a) makes verifier output hard to read and (b) isn't very Java-like, which may mean Hotspot isn't adapted to it. we probably need to switch to a BitSet to implement this correctly.

* implementation: is it a mistake to generate the global code in the constructor? should it be in "main" instead? (or at least some kind of secondary static void method to keep the generated boilerplate of main distinct.)

* implementation: ARGS might be cleaner if, at least internally, we could express a VariableDefinition with no initializer. maybe the other built-in variables would be better like that?

* implementation: globals are very slow. moving X and Y inside the loop (!) in mandelbrot.talc makes it 5x faster. not all globals need to be represented as static fields: we could recognize ones that escape, and make the rest local to the generated global method, or we could recognize ones that aren't modified after initialization and turn them into constants (even without constant inlining or hand-made "constant pool", that's still a win).

* implementation: should have an arbitrary-arity string concatenation AstNode. the simplifier should collect them up, and then the code generator can generate optimal code. (though the current simple scheme does pretty well. i wonder how long chains of string concatenation get in real-life code?)

* implementation: we could replace RealValue with java.lang.Double but we'd need to put all the RealValue implementations of the NumericValue methods somewhere. more useful would be replacing LRealValue; with D. it's not too hard to treat "real" as a primitive double and call static (DD)D methods in RealValue (i've done it, as proof). the awkward bits would be __get_item__/__set_item__ and methods that would like to work on any numeric type (which is easy given the current plan of exposing NumericValue in the language, though that actually opens up a can of worms because of the potential for mixed-mode arithmetic).

* implementation: BooleanValue is more convenient than Boolean because we know there are only two instances and can compare them by identity. given the price of getstatic, it might be worth investigating converting BooleanValue to I in generated loops and conditionals (where generated boilerplate is the consumer of the BooleanValue).

* implementation: we need our own "constant pool". if we're boxing everything but "string" (as we are at the time of writing) we're only getting the advantage of the real constant pool for strings. (we're partially getting it for RealValue, because we use a (D)LRealValue; constructor, and the primitive doubles go into the constant pool.)

* implementation: we could automatically recognize "final" variables and inline their values, even if we don't have a notion of "final" in the language (yet?).

* implementation: there's plenty more work we could do in AstSimplifier. we can evaluate constant expressions at compile time.
